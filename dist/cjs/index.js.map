{
  "version": 3,
  "sources": ["../esm/index.js"],
  "sourcesContent": ["import { Prisma } from \"@prisma/client\";\nimport { existsSync, mkdirSync, readFileSync, writeFileSync } from \"fs\";\nimport Handlebars from \"handlebars\";\nimport { resolve } from \"path\";\nimport { format } from \"prettier\";\nconst toPascalCase = (str) => str.charAt(0).toUpperCase() + str.slice(1);\nconst toCamelCase = (str) => str.charAt(0).toLowerCase() + str.slice(1);\nconst convertPrismaType = (type) => {\n    switch (type) {\n        case \"BigInt\":\n            return \"bigint\";\n        case \"Boolean\":\n            return \"boolean\";\n        case \"Bytes\":\n            return \"Uint8Array\";\n        case \"DateTime\":\n            return \"Date\";\n        case \"Decimal\":\n            return \"string\";\n        case \"Float\":\n            return \"number\";\n        case \"Int\":\n            return \"number\";\n        case \"Json\":\n            return \"object\";\n        case \"String\":\n            return \"string\";\n        default:\n            return \"unknown\";\n    }\n};\nconst ensureDirectory = (dirPath) => {\n    if (!existsSync(dirPath)) {\n        mkdirSync(dirPath, { recursive: true });\n    }\n};\nconst formatCode = async (content) => await format(content, {\n    parser: \"typescript\",\n    semi: true,\n    singleQuote: true,\n    useTabs: true,\n    tabWidth: 4,\n});\nconst writeFile = (filePath, content, overwrite) => {\n    if (existsSync(filePath) && !overwrite) {\n        console.log(`Skipped: ${filePath} already exists.`);\n        return;\n    }\n    writeFileSync(filePath, content, \"utf8\");\n    console.log(`Saved: ${filePath}`);\n};\nconst compileTemplate = (templatePath) => {\n    const source = readFileSync(templatePath, \"utf8\");\n    return Handlebars.compile(source, { noEscape: true });\n};\nconst generateFindByIdMethod = (upperKey, lowerKey, keyType, table) => `\r\nstatic findBy${upperKey} = async (${lowerKey}: ${keyType}) => {\r\n    return await this.client.${table}.findFirst({ where: { ${lowerKey} } });\r\n};\\n`;\nconst generateFindByUniqueMethod = (upperKey, lowerKey, keyType, table) => `\r\nstatic findBy${upperKey} = async (${lowerKey}: ${keyType}) => {\r\n    return await this.client.${table}.findFirst({ where: { ${lowerKey} } });\r\n};\\n`;\nconst saveRepository = async (repo, content, overwrite) => {\n    const dir = resolve(process.cwd(), \"PRG_repositories\");\n    ensureDirectory(dir);\n    const formattedContent = await formatCode(content);\n    const filePath = resolve(dir, `${toCamelCase(repo)}.repository.ts`);\n    writeFile(filePath, formattedContent, overwrite);\n};\nconst savePrismaUtils = async (overwrite) => {\n    const dir = resolve(process.cwd(), \"PRG_repositories\");\n    ensureDirectory(dir);\n    const content = `import { PrismaClient } from \"@prisma/client\"; export const client = new PrismaClient();`;\n    const formattedContent = await formatCode(content);\n    const filePath = resolve(dir, \"prisma.utils.ts\");\n    writeFile(filePath, formattedContent, overwrite);\n};\nconst replacePlaceholders = async (filePath, idContent, uniqueContent) => {\n    const fileData = readFileSync(filePath, \"utf8\");\n    const updatedData = fileData.replace(/\\/\\/ PRG_FIND_BY_ID/g, idContent).replace(/\\/\\/ PRG_FIND_BY_UNIQUE/g, uniqueContent);\n    const formattedCode = await formatCode(updatedData);\n    writeFileSync(filePath, formattedCode, \"utf8\");\n};\nexport const generateRepositories = async (overwrite = false) => {\n    if (!Prisma.dmmf?.datamodel) {\n        throw new Error(`Ensure schema is initialized by running \"npx prisma migrate dev --name init\".`);\n    }\n    const template = compileTemplate(resolve(__dirname, \"..\", \"template\", \"template.hbs\"));\n    const models = Prisma.dmmf?.datamodel?.models || [];\n    await savePrismaUtils(overwrite);\n    for (const model of models) {\n        let findByIdMethods = \"\";\n        let findByUniqueMethods = \"\";\n        model.fields.forEach((field) => {\n            if (field.kind === \"scalar\" && field.isId) {\n                findByIdMethods += generateFindByIdMethod(toPascalCase(field.name), field.name, convertPrismaType(field.type), toCamelCase(model.name));\n            }\n            if (field.kind === \"scalar\" && field.isUnique) {\n                findByUniqueMethods += generateFindByUniqueMethod(toPascalCase(field.name), field.name, convertPrismaType(field.type), toCamelCase(model.name));\n            }\n        });\n        let content = template({\n            repo: model.name,\n            table: toCamelCase(model.name),\n        });\n        await saveRepository(model.name, content, overwrite);\n        const filePath = resolve(process.cwd(), \"PRG_repositories\", `${toCamelCase(model.name)}.repository.ts`);\n        await replacePlaceholders(filePath, findByIdMethods, findByUniqueMethods);\n    }\n};\n"],
  "mappings": "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",
  "names": ["Handlebars"]
}
