// https://www.client.io/docs/orm/reference/client-client-reference#model-queries

import { Prisma } from '@prisma/client';
import { client } from "./prisma.utils";

export class {{repo}} {
    private static client = client;

    static findUnique = async (options: {
        where: Prisma.{{repo}}WhereUniqueInput;
        select?: Prisma.{{repo}}Select;
        include?: Prisma.{{repo}}Include;
        // omit?: Prisma.{{repo}}Omit;
    }) => {
        if (options.select && options.include) {
            throw new Error("You cannot specify both 'select' and 'include'.");
        }

        const args: Prisma.{{repo}}FindUniqueArgs = {
            where: options.where,
            ...(options.select ? { select: options.select } : {}),
            ...(options.include ? { include: options.include } : {}),
            // omit: options.omit,
        };

        return await this.client.{{table}}.findUnique(args);
    };

    static findUniqueOrThrow = async (options: {
        where: Prisma.{{repo}}WhereUniqueInput;
        select?: Prisma.{{repo}}Select;
        include?: Prisma.{{repo}}Include;
        // omit?: Prisma.{{repo}}Omit;
    }) => {
        if (options.select && options.include) {
            throw new Error("You cannot specify both 'select' and 'include'.");
        }

        const args: Prisma.{{repo}}FindUniqueOrThrowArgs = {
            where: options.where,
            ...(options.select ? { select: options.select } : {}),
            ...(options.include ? { include: options.include } : {}),
            // omit: options.omit,
        };

        return await this.client.{{table}}.findUniqueOrThrow(args);
    };

    static findFirst = async (options: {
        select?: Prisma.{{repo}}Select;
        include?: Prisma.{{repo}}Include;
        // omit?: Prisma.{{repo}}Omit;
        where?: Prisma.{{repo}}WhereInput;
        orderBy?: Prisma.{{repo}}OrderByWithRelationInput | Prisma.{{repo}}OrderByWithRelationInput[];
    }) => {
        if (options.select && options.include) {
            throw new Error("You cannot specify both 'select' and 'include'.");
        }

        const args: Prisma.{{repo}}FindFirstArgs = {
            ...(options.select ? { select: options.select } : {}),
            ...(options.include ? { include: options.include } : {}),
            // omit: options.omit,
            where: options.where,
            orderBy: options.orderBy,
        };

        return await this.client.{{table}}.findFirst(args);
    };

    static findFirstOrThrow = async (options: {
        select?: Prisma.{{repo}}Select;
        include?: Prisma.{{repo}}Include;
        // omit?: Prisma.{{repo}}Omit;
        where?: Prisma.{{repo}}WhereInput;
        orderBy?: Prisma.{{repo}}OrderByWithRelationInput | Prisma.{{repo}}OrderByWithRelationInput[];
    }) => {
        if (options.select && options.include) {
            throw new Error("You cannot specify both 'select' and 'include'.");
        }

        const args: Prisma.{{repo}}FindFirstOrThrowArgs = {
            ...(options.select ? { select: options.select } : {}),
            ...(options.include ? { include: options.include } : {}),
            // omit: options.omit,
            where: options.where,
            orderBy: options.orderBy,
        };

        return await this.client.{{table}}.findFirstOrThrow(args);
    };

    static findMany = async (options: {
        select?: Prisma.{{repo}}Select;
        include?: Prisma.{{repo}}Include;
        // omit?: Prisma.{{repo}}Omit;
        where?: Prisma.{{repo}}WhereInput;
        orderBy?: Prisma.{{repo}}OrderByWithRelationInput | Prisma.{{repo}}OrderByWithRelationInput[];
        cursor?: Prisma.{{repo}}WhereUniqueInput;
        take?: number;
        skip?: number;
        distinct?: Prisma.{{repo}}ScalarFieldEnum | Prisma.{{repo}}ScalarFieldEnum[];
    }) => {
        if (options.select && options.include) {
            throw new Error("You cannot specify both 'select' and 'include'.");
        }

        const args: Prisma.{{repo}}FindManyArgs = {
            ...(options.select ? { select: options.select } : {}),
            ...(options.include ? { include: options.include } : {}),
            // omit: options.omit,
            where: options.where,
            orderBy: options.orderBy,
            cursor: options.cursor,
            skip: options.skip,
            take: options.take,
            distinct: options.distinct,
        };

        return await this.client.{{table}}.findMany(args);
    };

    static create = async (options: {
        data: Prisma.{{repo}}CreateInput;
        select?: Prisma.{{repo}}Select;
        include?: Prisma.{{repo}}Include;
        // omit?: Prisma.{{repo}}Omit;
    }) => {
        if (options.select && options.include) {
            throw new Error("You cannot specify both 'select' and 'include'.");
        }

        const args: Prisma.{{repo}}CreateArgs = {
            data: options.data,
            ...(options.select ? { select: options.select } : {}),
            ...(options.include ? { include: options.include } : {}),
            // omit: options.omit,
        };

        return await this.client.{{table}}.create(args);
    };

    static update = async (options: {
        data: Prisma.{{repo}}UpdateInput;
        where: Prisma.{{repo}}WhereUniqueInput;
        select?: Prisma.{{repo}}Select;
        include?: Prisma.{{repo}}Include;
        // omit?: Prisma.{{repo}}Omit;
    }) => {
        if (options.select && options.include) {
            throw new Error("You cannot specify both 'select' and 'include'.");
        }

        const args: Prisma.{{repo}}UpdateArgs = {
            data: options.data,
            where: options.where,
            ...(options.select ? { select: options.select } : {}),
            ...(options.include ? { include: options.include } : {}),
            // omit: options.omit,
        };

        return await this.client.{{table}}.update(args);
    };

    static upsert = async (options: {
        create: Prisma.{{repo}}CreateInput;
        update: Prisma.{{repo}}UpdateInput;
        where: Prisma.{{repo}}WhereUniqueInput;
        select?: Prisma.{{repo}}Select;
        include?: Prisma.{{repo}}Include;
        // omit?: Prisma.{{repo}}Omit;
    }) => {
        if (options.select && options.include) {
            throw new Error("You cannot specify both 'select' and 'include'.");
        }

        const args: Prisma.{{repo}}UpsertArgs = {
            create: options.create,
            update: options.update,
            where: options.where,
            ...(options.select ? { select: options.select } : {}),
            ...(options.include ? { include: options.include } : {}),
            // omit: options.omit,
        };

        return await this.client.{{table}}.upsert(args);
    };

    static delete = async (options: {
        where: Prisma.{{repo}}WhereUniqueInput;
        select?: Prisma.{{repo}}Select;
        include?: Prisma.{{repo}}Include;
        // omit?: Prisma.{{repo}}Omit;
    }) => {
        if (options.select && options.include) {
            throw new Error("You cannot specify both 'select' and 'include'.");
        }

        const args: Prisma.{{repo}}DeleteArgs = {
            where: options.where,
            ...(options.select ? { select: options.select } : {}),
            ...(options.include ? { include: options.include } : {}),
            // omit: options.omit,
        };

        return await this.client.{{table}}.delete(args);
    };

    static createMany = async (options: {
        data: Prisma.{{repo}}CreateManyInput[];
        // skipDuplicates?: boolean
    }) => {
        const args: Prisma.{{repo}}CreateManyArgs = {
            data: options.data,
            // skipDuplicates: options.skipDuplicates,
        };

        return await this.client.{{table}}.createMany(args);
    };

    static createManyAndReturn = async (options: {
        data: Prisma.{{repo}}CreateManyInput[];
        select?: Prisma.{{repo}}Select;
        include?: Prisma.{{repo}}Include;
        // omit?: Prisma.{{repo}}Omit;
        // skipDuplicates?: boolean
    }) => {
        const args: Prisma.{{repo}}CreateManyAndReturnArgs = {
            data: options.data,
            ...(options.select ? { select: options.select } : {}),
            ...(options.include ? { include: options.include } : {}),
            // omit: options.omit,
            // skipDuplicates: options.skipDuplicates,
        };

        return await this.client.{{table}}.createManyAndReturn(args);
    };

    static updateMany = async (options: {
        data: Prisma.{{repo}}UpdateManyMutationInput;
        where?: Prisma.{{repo}}WhereInput;
    }) => {
        const args: Prisma.{{repo}}UpdateManyArgs = {
            data: options.data,
            where: options.where,
        };

        return await this.client.{{table}}.updateMany(args);
    };

    static deleteMany = async (options: { where?: Prisma.{{repo}}WhereInput }) => {
        const args: Prisma.{{repo}}DeleteManyArgs = {
            where: options.where,
        };

        return await this.client.{{table}}.deleteMany(args);
    };

    static count = async (options: {
        where?: Prisma.{{repo}}WhereInput;
        orderBy?: Prisma.{{repo}}OrderByWithRelationInput;
        cursor?: Prisma.{{repo}}WhereUniqueInput;
        take?: number;
        skip?: number;
    }) => {
        const args: Prisma.{{repo}}CountArgs = {
            where: options.where,
            orderBy: options.orderBy,
            cursor: options.cursor,
            take: options.take,
            skip: options.skip,
        };

        return await this.client.{{table}}.count(args);
    };

    static aggregate = async (options: {
        where?: Prisma.{{repo}}WhereInput;
        orderBy?: Prisma.{{repo}}OrderByWithRelationInput;
        cursor?: Prisma.{{repo}}WhereUniqueInput;
        take?: number;
        skip?: number;
        _count?: true | Prisma.{{repo}}CountAggregateInputType;
        _avg?: Prisma.{{repo}}AvgAggregateInputType;
        _sum?: Prisma.{{repo}}SumAggregateInputType;
        _min?: Prisma.{{repo}}MinAggregateInputType;
        _max?: Prisma.{{repo}}MaxAggregateInputType;
    }) => {
        const args: Prisma.{{repo}}AggregateArgs = {
            where: options.where,
            orderBy: options.orderBy,
            cursor: options.cursor,
            take: options.take,
            skip: options.skip,
            _count: options._count,
            _avg: options._avg,
            _sum: options._sum,
            _min: options._min,
            _max: options._max,
        };

        return await this.client.{{table}}.aggregate(args);
    };

    // BUG: Fix scheduled for the next version (release date TBD)
    // static groupBy = async (options: {
    //     by: Prisma.{{repo}}ScalarFieldEnum | Prisma.{{repo}}ScalarFieldEnum[];
    //     orderBy: Prisma.{{repo}}OrderByWithAggregationInput | Prisma.{{repo}}OrderByWithAggregationInput[] | undefined;
    //     where: Prisma.{{repo}}WhereInput;
    //     having: Prisma.{{repo}}ScalarWhereWithAggregatesInput;
    //     take: number;
    //     skip: number;
    //     _count: true | Prisma.{{repo}}CountAggregateInputType;
    //     _avg: Prisma.{{repo}}AvgAggregateInputType;
    //     _sum: Prisma.{{repo}}SumAggregateInputType;
    //     _min: Prisma.{{repo}}MinAggregateInputType;
    //     _max: Prisma.{{repo}}MaxAggregateInputType;
    // }) => {
    //     const args: Prisma.{{repo}}GroupByArgs = {
    //         by: options.by,
    //         where: options.where,
    //         orderBy: options.orderBy,
    //         having: options.having,
    //         take: options.take,
    //         skip: options.skip,
    //         _count: options._count,
    //         _avg: options._avg,
    //         _sum: options._sum,
    //         _min: options._min,
    //         _max: options._max,
    //     };

    //     return await this.client.{{table}}.groupBy(args);
    // };
}